### 线程

经典观点是一个程序只有一个执行点（一个程序计数器，用来存放要执行的指令），但多线程（multi-threaded）程序会有多个执行点（多个程序计数器，每个都用于取指令和执行）。

换一个角度来看，每个线程类似于独立的进程，只有一点区别：它们共享地址空间，从而能够访问相同的数据。

（不完全正确的理解：进程之间共享了内存空间，那么他们就是进程了。）

我们需要一个或多个线程 控制块（Thread Control Block，TCB），保存每个线程的状态。但是，与进程相比，线程之间的上下文切换有一点主要区别：地址空间保持不变（即不需要切换当前使用的页表）。

线程和进程之间的另一个主要区别在于栈。在简单的传统进程地址空间模型 [我们现在 可以称之为单线程（single-threaded）进程] 中，只有一个栈，通常位于地址空间的底部。

<img src="D:\OS-TEP\OS-TEP\note\第26章 并发：介绍\屏幕截图 2024-01-21 205149.png" style="zoom: 67%;" />

然而，在多线程的进程中，每个线程独立运行，当然可以调用各种例程来完成正在执行的任何工作。不是地址空间中只有一个栈，而是每个线程都有一个栈。

每个线程通常都有自己的寄存器上下文。

#### 26.1 实例：线程创建

假设我们想运行一个程序，它创建两个线程，每个线程都做了一些独立的工作，在这例子中，打印“A”或“B”。

主程序创建了两个线程，分别执行函数 mythread()，但是传入不同的参数（字符串类型 的 A 或者 B）。一旦线程创建，可能会立即运行（取决于调度程序的兴致），或者处于就绪 状态，等待执行。创建了两个线程（T1 和 T2）后，主程序调用 pthread_join()，等待特定线 程完成。

```

```

