### 线程

经典观点是一个程序只有一个执行点（一个程序计数器，用来存放要执行的指令），但多线程（multi-threaded）程序会有多个执行点（多个程序计数器，每个都用于取指令和执行）。

换一个角度来看，每个线程类似于独立的进程，只有一点区别：它们共享地址空间，从而能够访问相同的数据。

（不完全正确的理解：进程之间共享了内存空间，那么他们就是进程了。）

我们需要一个或多个线程 控制块（Thread Control Block，TCB），保存每个线程的状态。但是，与进程相比，线程之间的上下文切换有一点主要区别：地址空间保持不变（即不需要切换当前使用的页表）。

线程和进程之间的另一个主要区别在于栈。在简单的传统进程地址空间模型 [我们现在 可以称之为单线程（single-threaded）进程] 中，只有一个栈，通常位于地址空间的底部。

<img src="D:\OS-TEP\OS-TEP\note\第26章 并发：介绍\屏幕截图 2024-01-21 205149.png" style="zoom: 67%;" />

然而，在多线程的进程中，每个线程独立运行，当然可以调用各种例程来完成正在执行的任何工作。不是地址空间中只有一个栈，而是每个线程都有一个栈。

每个线程通常都有自己的寄存器上下文。

#### 26.1 实例：线程创建

假设我们想运行一个程序，它创建两个线程，每个线程都做了一些独立的工作，在这例子中，打印“A”或“B”。

主程序创建了两个线程，分别执行函数 mythread()，但是传入不同的参数（字符串类型 的 A 或者 B）。一旦线程创建，可能会立即运行（取决于调度程序的兴致），或者处于就绪 状态，等待执行。创建了两个线程（T1 和 T2）后，主程序调用 pthread_join()，等待特定线 程完成。

```c
#include <stdio.h>
#include <assert.h>
#include <pthread.h>

//线程函数的参数类型被限制为 void *。这种设计是为了通用性和灵活性。
void *mythread(void *arg){
	printf("%s\n",(char *)arg);
	return NULL;
}

int
main(int argc,char *argv[]){
//一个抽象结构，具体取决于编译器	
	pthread_t p1,p2;
//return code
	int rc;
	printf("main:gebin\n");
//当创建成功create会返回0,如果assert内的值为false，	程序会中止，并打印错误信息。
	rc = pthread_create(&p1, NULL ,mythread,"A");assert(rc == 0);
	rc = pthread_create(&p2, NULL ,mythread,"B");assert(rc == 0);
//如果join一个已经完成的线程，其会立即退出
	rc = pthread_join(p1,NULL);assert(rc == 0);
	rc = pthread_join(p2,NULL);assert(rc == 0);
	printf("main:end\n");
	return 0;
}
```

实际上，给定一系列指令，有很多可能的顺序，这取决于调度程序决定在给定时刻运行哪个线程。

如你所见，线程创建有点像进行函数调用。然而，并不是首先执行函数然后返回给调用者，而是为被调用的例程创建一个新的执行线程，它可以独立于调用者运行，可能在从创建者返回之前运行，但也许会晚得。

**26.2 为什么更糟糕：共享数据** 

上面演示的简单线程示例非常有用，它展示了线程如何创建，根据调度程序的决定， 它们如何以不同顺序运行。但是，它没有展示线程在访问共享数据时如何相互作用。

```c
#include <stdio.h>
#include <pthread.h>
//#include "mythreads.h"
//代表这是个静态变量（相当于全局变量，但是只在此文件中可见），并且此变量不该被编译器进行优化
static volatile int counter = 0;

//
// mythread()
//

// Simply adds 1 to counter repeatedly, in a loop
// No, this is not how you would add 10,000,000 to
// a counter, but it shows the problem nicely.
//
void *
mythread(void *arg) {
	printf("%s: begin\n", (char *) arg);
	int i;
	for (i = 0; i < 1e7; i++) {
		counter = counter + 1;	//改成counter++也会有问题呃呃
        						//发现他们的汇编代码一样ww
        						//++counter也一样
	}
	printf("%s: done\n", (char *) arg);
	return NULL;
}

//
// main()
//
// Just launches two threads (pthread_create)
// and then waits for them (pthread_join)
//
int
main(int argc, char *argv[]) {
	pthread_t p1, p2;
	int rc;
	printf("main: begin (counter = %d)\n", counter);
	rc = pthread_create(&p1, NULL, mythread, "A");
	rc = pthread_create(&p2, NULL, mythread, "B");
	
	// join waits for the threads to finish
	rc = pthread_join(p1, NULL);
	rc = pthread_join(p2, NULL);
	printf("main: done with both (counter = %d)\n", counter);
	return 0;
}

```

每次运行不但会产生错误，而且得到不同的结果！有一个大问题：为什么会发生这种情况？

> **提示：了解并使用工具** 
>
> 你应该学习使用新的工具，帮助你编程、调试和理解计算机系统。我们使用一个漂亮的工具，名为 反汇编程序（disassembler）。如果对可执行文件运行反汇编程序，它会显示组成程序的汇编指令。例如， 如果我们想要了解更新计数器的底层代码（如我们的例子），就运行 objdump（Linux）来查看汇编代码：
>
> ```shell
>   prompt> objdump -d main
> ```
>
>  这样做会产生程序中所有指令的长列表，整齐地标明（特别是如果你使用-g 标志编译），其中包含 程序中的符号信息。objdump 程序只是应该学习使用的许多工具之一。像 gdb 这样的调试器，像 valgrind 或 purify 这样的内存分析器，当然编译器本身也应该花时间去了解更多信息。工具用得越好，就可以建 立更好的系统。

我们对mythread()函数进程反汇编

```assembly
;mov %rax %rbx 相当于 rbx = rax
movl   $0x0,-0x4(%rbp) ; 将常数0存入局部变量的一个位置
jmp    11ed <mythread+0x44> ; 无条件跳转到指定地址

    ; 以下部分是一个循环，对一个全局变量 counter 进行加法操作
mov    0x2e34(%rip),%eax ; 读取全局变量 counter 的值
add    $0x1,%eax        ; 将其加1
mov    %eax,0x2e2b(%rip) ; 存储回全局变量 counter
addl   $0x1,-0x4(%rbp)   ; 局部变量加1

cmpl   $0x98967f,-0x4(%rbp) ; 比较局部变量和常数的值
jle    11da <mythread+0x31> ; 如果比较结果为小于等于，则跳转到循环部分
```

可以发现在对全局变量的赋值上，会导致问题。

**26.3 核心问题：不可控的调度** 

为了理解为什么会发生这种情况，我们必须了解编译器为更新计数器生成的代码序列。 在这个例子中，我们只是想给 counter 加上一个数字（1）。因此，做这件事的代码序列可能 看起来像这样（在 x86 中）

```assembly
mov 0x8049a1c, %eax 
add $0x1, %eax 
mov %eax, 0x8049a1c 
```

1. 线程1读取 `counter` 的值为50到寄存器eax。
2. 时钟中断导致线程1被暂停，切换到线程2。
3. 线程2读取 `counter` 的值为50到寄存器eax，然后递增eax的值为51，并将51写回 `counter`。
4. 线程1恢复执行，递增eax的值为51，并将51写回 `counter`。

最终，`counter` 的值是51，而不是期望的52。这是由于两个线程在没有同步机制的情况下同时修改了共享的变量，导致竞态条件的结果不确定。

为了更好地理解问题，让我们追踪一下详细的执行。假设在这个例子中，上面的代码 被加载到内存中的地址 100 上，就像下面的序列一样（熟悉类似 RISC 指令集的人请注意： x86 具有可变长度指令。这个 mov 指令占用 5 个字节的内存，add 只占用 3 个字节）

```assembly
100 mov 0x8049a1c, %eax 
105 add $0x1, %eax 
108 mov %eax, 0x8049a1c 
```

这里展示的情况称为**竞态条件**（race condition）：结果取决于代码的时间执行。

由于执行这段代码的多个线程可能导致竞争状态，因此我们将此段代码称为**临界区** （critical section）。

**临界区**是访问共享变量（或更一般地说，共享资源）的代码片段，一定不 能由多个线程同时执行。

<img src="D:\OS-TEP\OS-TEP\note\第26章 并发：介绍\屏幕截图 2024-01-21 230901.png" style="zoom:80%;" />

我们真正想要的代码就是所谓的互斥（mutual exclusion）。这个属性保证了如果一个线 程在临界区内执行，其他线程将被阻止进入临界区。

事实上，所有这些术语都是由 Edsger Dijkstra 创造的，他是该领域的先驱，并且因为这 项工作和其他工作而获得了图灵奖。（respect！！！）

#### **26.4 原子性愿望** 

解决这个问题的一种途径是拥有更强大的指令，单步就能完成要做的事，从而消除不 合时宜的中断的可能性。比如，如果有这样一条超级指令怎么样？

```assembly
memory-add 0x8049a1c, $0x1
```

假设这条指令将一个值添加到内存位置，并且硬件保证它以原子方式（atomically）执 行。当指令执行时，它会像期望那样执行更新。它不能在指令中间中断，因为这正是我们 从硬件获得的保证：发生中断时，指令根本没有运行，或者运行完成，没有中间状态。硬 件也可以很漂亮，不是吗？

在这里，原子方式的意思是“作为一个单元”，有时我们说“全部或没有”。我们希望 以原子方式执行 3 个指令的序列：

```assembly
mov 0x8049a1c, %eax 
add $0x1, %eax 
mov %eax, 0x8049a1c
```

我们说过，如果有一条指令来做到这一点，我们可以发出这条指令然后完事。但在一 般情况下，不会有这样的指令。设想我们要构建一个并发的 B 树，并希望更新它。我们真 的希望硬件支持“B 树的原子性更新”指令吗？可能不会，至少理智的指令集不会。(又要开始徒手搓高达了......)

因此，我们要做的是要求硬件提供一些有用的指令，可以在这些指令上构建一个通用 的集合，即所谓的同步原语（synchronization primitive）。通过使用这些硬件同步原语，加上 操作系统的一些帮助，我们将能够构建多线程代码，以同步和受控的方式访问临界区，从 而可靠地产生正确的结果—— 尽管有并发执行的挑战。很棒，对吗？

> 补充：关键并发术语
>
>  临界区、竞态条件、不确定性、互斥执行
>
> 这 4 个术语对于并发代码来说非常重要，我们认为有必要明确地指出。 请参阅 Dijkstra 的一些早期 著作[D65，D68]了解更多细节。 
>
> - 临界区（critical section）是访问共享资源的一段代码，资源通常是一个变量或数据结构。 
> - 竞态条件（race condition）出现在多个执行线程大致同时进入临界区时，它们都试图更新共享 的数据结构，导致了令人惊讶的（也许是不希望的）结果。 
> - 不确定性（indeterminate）程序由一个或多个竞态条件组成，程序的输出因运行而异，具体取 决于哪些线程在何时运行。这导致结果不是确定（deterministic），而我们通常期望计算机系统给出确 定的结果。 
> - 为了避免这些问题，线程应该使用某种互斥（mutual exclusion）原语。这样做可以保证只有一 个线程进入临界区，从而避免出现竞态，并产生确定的程序输出。

> 关键问题：如何实现同步
>
> ​	为了构建有用的同步原语，需要从硬件中获得哪些支持？需要从操作系统中获得什么支持？如何正 确有效地构建这些原语？程序如何使用它们来获得期望的结果？

**26.5 还有一个问题：等待另一个线程**

本章提出了并发问题，就好像线程之间只有一种交互，即访问共享变量，因此需要为 临界区支持原子性。事实证明，还有另一种常见的交互，即一个线程在继续之前必须等待 另一个线程完成某些操作。例如，当进程执行磁盘 I/O 并进入睡眠状态时，会产生这种交互。 当 I/O 完成时，该进程需要从睡眠中唤醒，以便继续进行。

因此，在接下来的章节中，我们不仅要研究如何构建对同步原语的支持来支持原子性， 还要研究支持在多线程程序中常见的睡眠/唤醒交互的机制。

**26.6 小结：为什么操作系统课要研究并发**

在结束之前，你可能会有一个问题：为什么我们要在 OS 类中研究并发？一个词：“历 史”。操作系统是第一个并发程序，许多技术都是在操作系统内部使用的。后来，在多线程 的进程中，应用程序员也必须考虑这些事情。

> 提示：使用原子操作 
>
> 原子操作是构建计算机系统的最强大的基础技术之一，从计算机体系结构到并行代码（我们在这里 研究的内容）、文件系统（我们将很快研究）、数据库管理系统，甚至分布式系统[L+93]。 
>
> 将一系列动作原子化（atomic）背后的想法可以简单用一个短语表达：“全部或没有”。看上去，要 么你希望组合在一起的所有活动都发生了，要么它们都没有发生。不会看到中间状态。有时，将许多行 为组合为单个原子动作称为事务（transaction），这是一个在数据库和事务处理世界中非常详细地发展的 概念[GR92]。 
>
> 在探讨并发的主题中，我们将使用同步原语，将指令的短序列变成原子性的执行块。但是我们会看 到，原子性的想法远不止这些。例如，文件系统使用诸如日志记录或写入时复制等技术来自动转换其磁 盘状态，这对于在系统故障时正确运行至关重要。如果不明白，不要担心——后续某章会探讨。