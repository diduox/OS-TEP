#### 作业

我们需要用到的一小段代码：

```assembly
mov 2000, %ax   # get the value at the address
add $1, %ax     # increment it
mov %ax, 2000   # store it back
```

一些关于寄存器地址的规则

-   2000        			    -> the number (2000) is the address
-   (%cx)       			    -> contents of register (in parentheses) forms the address
-   1000(%dx)   	       -> the number + contents of the register form the address
-   10(%ax,%bx) 		 -> the number + reg1 + reg2 forms the address

**mov 2000, %ax **

表示 %ax = 2000

**add $1, %ax**

表示 %ax = %ax + 1,$1代表这是一个立即数（代表1不是一个地址）。

**x86.py 这个程序让你看到不同的线程交替如何导致或避免竞态条件。请参阅 README 文件，了解程序如何工作及其基本输入的详细信息，然后回答以下问题**

##### 1．开始，我们来看一个简单的程序，“loop.s”。首先，阅读这个程序，看看你是否能理解它：cat loop.s。然后，用这些参数运行它：

这指定了一个单线程，每 100 条指令产生一个中断，并且追踪寄存器%dx。你能弄清楚 %dx 在运行过程中的价值吗？你有答案之后，运行上面的代码并使用-c 标志来检查你的答 案。注意答案的左边显示了右侧指令运行后寄存器的值（或内存的值）

```shell
./x86.py -p loop.s -t 1 -i 100 -R dx 
```

**loop.s**

```assembly
.main
.top
sub  $1,%dx
test $0,%dx     
jgte .top         
halt
```

**运行结果**

```assembly
   dx          Thread 0         
    0   
   -1   1000 sub  $1,%dx
   -1   1001 test $0,%dx
   -1   1002 jgte .top
   -1   1003 halt
```

**2．现在运行相同的代码，但使用这些标志：**

```shell
./x86.py -p loop.s -t 2 -i 100 -a dx=3,dx=3 -R dx 
```

这指定了两个线程，并将每个%dx 寄存器初始化为 3。%dx 会看到什么值？使用-c 标志运行以查看答案。多个线程的存在是否会影响计算？这段代码有竞态条件吗？

不存在竞态条件，因为每个线程都有自己栈和自己的寄存器。

```
   dx          Thread 0                Thread 1         
    3   
    2   1000 sub  $1,%dx
    2   1001 test $0,%dx
    2   1002 jgte .top
    1   1000 sub  $1,%dx
    1   1001 test $0,%dx
    1   1002 jgte .top
    0   1000 sub  $1,%dx
    0   1001 test $0,%dx
    0   1002 jgte .top
   -1   1000 sub  $1,%dx
   -1   1001 test $0,%dx
   -1   1002 jgte .top
   -1   1003 halt
    3   ----- Halt;Switch -----  ----- Halt;Switch -----  
    2                            1000 sub  $1,%dx
    2                            1001 test $0,%dx
    2                            1002 jgte .top
    1                            1000 sub  $1,%dx
    1                            1001 test $0,%dx
    1                            1002 jgte .top
    0                            1000 sub  $1,%dx
    0                            1001 test $0,%dx
    0                            1002 jgte .top
   -1                            1000 sub  $1,%dx
   -1                            1001 test $0,%dx
   -1                            1002 jgte .top
   -1                            1003 halt
```

##### 3．现在运行以下命令：

```shell
./x86.py -p loop.s -t 2 -i 3 -r -a dx=3,dx=3 -R dx
```

这使得中断间隔非常小且随机。使用不同的种子和-s 来查看不同的交替。中断频率是否 会改变这个程序的行为？（-r代表中断随机，i是最大值）

不会改变。

##### 4．接下来我们将研究一个不同的程序（looping-race-nolock.s）。

该程序访问位于内存地址 2000 的共享变量。简单起见，我们称这个变量为 x。使用单 线程运行它，并确保你了解它的功能，如下所示

```shell
./x86.py -p looping-race-nolock.s -t 1 -M 2000 
```

在整个运行过程中，x（即内存地址为 2000）的值是多少？使用-c 来检查你的答案。

**looping-race-nolock.s**

```assembly
# assumes %bx has loop count in it

.main
.top	
# critical section
mov 2000, %ax  # get 'value' at address 2000
add $1, %ax    # increment it
mov %ax, 2000  # store it back

# see if we're still looping
sub  $1, %bx
test $0, %bx
jgt .top	

halt
```

答案为1（没有指定%bx初始值啊啊啊啊）。

**5．现在运行多个迭代和线程：**

```shell
./x86.py -p looping-race-nolock.s -t 2 -a bx=3 -M 2000 
```

你明白为什么每个线程中的代码循环 3 次吗？x 的最终值是什么？

下面是循环条件 这相当于一个do..while()结构，每次循环会减去1。

x 的最终值在这里是 6 （因为关闭了中断）。

##### 6．现在以随机中断间隔运行：

```shell
 ./x86.py -p looping-race-nolock.s -t 2 -M 2000 -i 4 -r -s 0
```

 然后改变随机种子，设置-s 1，然后-s 2 等。只看线程交替，你能说出 x 的最终值是什 么吗？中断的确切位置是否重要？在哪里发生是安全的？中断在哪里会引起麻烦？换句话 说，临界区究竟在哪里？

不能说出x的最终值，中断的位置重要，在临界区以外的打断是安全的，中断在临界区会引起麻烦。临界区在有全局变量的位置上。

**7．现在使用固定的中断间隔来进一步探索程序**

运行：

```assembly
./x86.py -p looping-race-nolock.s -a bx=1 -t 2 -M 2000 -i 1
```

看看你能否猜测共享变量 x 的最终值是什么。当你改用-i 2，-i 3 等标志呢？对于哪个中 断间隔，程序会给出“正确的”最终答案？

i = 3是正确的答案

**8．现在为更多循环运行相同的代码（例如 set -a bx = 100）。使用-i 标志设置哪些中断 间隔会导致“正确”结果？哪些间隔会导致令人惊讶的结果？**

间隔为3或3的倍数会导致正确结果（仅在此程序）。

1 或 2 结果为100；4的结果为160。

**9．我们来看本作业中最后一个程序（wait-for-me.s）**

像这样运行代码：

```shell
./x86.py -p wait-for-me.s -a ax=1,ax=0 -R ax -M 2000
```

这将线程 0 的%ax 寄存器设置为 1，并将线程 1 的值设置为 0，在整个运行过程中观察 %ax 和内存位置 2000 的值。代码的行为应该如何？线程使用的 2000 位置的值如何？它的 最终值是什么？

**wait-for-me.s**

```assembly
.main
test $1, %ax     # ax should be 1 (signaller) or 0 (waiter)
je .signaller

.waiter	
mov  2000, %cx
test $1, %cx
jne .waiter
halt

.signaller
mov  $1, 2000
halt
```

最终值为1。waiter不断循环直到%cx = 1;(其实因为没有中断，并且ax = 1的线程先执行，所以不存在这种情况)

##### 10．现在改变输入：

```shell
./x86.py -p wait-for-me.s -a ax=0,ax=1 -R ax -M 2000
```

线程行为如何？线程 0 在做什么？改变中断间隔（例如，-i 1000，或者可能使用随机间 隔）会如何改变追踪结果？程序是否高效地使用了 CPU？

线程0在无限循环，程序没有高效使用CPU