#### 插叙：内存操作API

##### 14.1 内存类型 

在运行一个C程序的时候，会分配两种类型的内存。第一种称为栈内存，它的申请和释放操作是编译器来隐式管理的，所以有时也称为自动（automatic）内存。

C中申请栈内存很容易。

```c
void func() { 
 int x; // declares an integer on the stack 
 ... 
}
```

编译器完成剩下的事情，确保在你进入func()函数的时候，在栈上开辟空间。当你从该函数退出时，编译器释放内存。因此，如果你希望某些信息存在于函数调用之外，建议不要把它们放在栈上。

对于长期内存的需求，我们需要第二种类型的内存，即所谓的堆内存，其中所有的申请和释放操作都由程序员显示地完成。

```c
void func() { 
 int *x = (int *) malloc(sizeof(int)); 
 ... 
} 
```

这段代码，栈的分配和堆的分配都在同一行：int *x 表明为一个整型指针分配空间，随后程序调用malloc()的时候，它会在堆上请求整数的空间，函数返回一个整数的地址（失败时则返回NULL），然后将其储存在栈中以供程序使用。

###### TIPS:经实验证明，声明在外部的全局变量被隐式的放在了堆内存里。

```c
#include <stdio.h>
#include <stdlib.h>
int y = 20;
int main(int argc, char *argv[]) {
    printf("location of code : %p\n", (void *) main);
    printf("location of heap : %p\n", (void *) malloc(1));
    int x = 3;
    printf("location of stack : %p\n", (void *) &x);

    printf("location of global : %p\n", (void *) &y);
    return x;
}
```

```
location of code : 0x5654b032a189
location of heap : 0x5654b21af6b0
location of stack : 0x7ffdd696dfc4
location of global : 0x5654b032d010
```

##### 14.2 malloc()调用 

***请注意，C 中的 NULL 实际上并不是什么特别的东西，只是一个值为 0 的宏。***

malloc函数非常简单：传入要申请的堆空间的大小，它成功就返回一个指向新申请空间的指针，失败就返回NULL。

man手册展示了使用malloc需要怎么做 输入 man malloc。

> #include <stdlib.h>
>
> void *malloc(size_t size);

从手册的概要可以得知，只需要包含头文件stdlib.h就可以使用malloc了。但实际上，甚至都不需要这么做，因为C库是C程序默认链接的，其中就有mallock()代码，加上这个头文件知识让编译器检查你是否正确调用了malloc()（即传入参数的数目正确且类型正确）。

malloc 只需要一个 size_t 类型参数，该参数表示你需要多少个字节。然而，大多数程序员并不会直接传入数字（比如 10）。事实上，这样做会被但为是不太好的形式。替代方案 是使用各种函数和宏。例如，为了给双精度浮点数分配空间，只要这样：

```c
double *d = (double *) malloc(sizeof(double));
```

> **提示：如果困惑，动手试试** 
>
> 如果你不确定要用的一些函数或者操作符的行为，唯一的办法就是试一下，确保它的行为符合你的期望。虽然读手册或其他文档是有用的，但在实际中如何使用更为重要。实际上，我们正是通过这样做， 来确保关于 sizeof()我们所说的都是真的！

在C中，sizeof()通常被认为是编译时运算符，意味着这个大小是在编译时就已直到，因此被替换为一个数。

出于这个原因，sizeof()被正确地认为是一个操作符，而不是一个函数调用（函数调用只在运行时发生）。

你也可以传入一个变量的名字（而不只是类型）给 sizeof()（今天刚知道能传入类型名......），但在一些情况下，可能得不到你要的结果，所以要小心使用。例如，看看下面的代码片段：

```c
int *x = malloc(10 * sizeof(int)); 
printf("%d\n", sizeof(x)); 
```

在第一行，我们为 10 个整数的数组声明了空间，这很好，很漂亮。但是，当我们在下 一行使用 sizeof()时，它将返回一个较小的值，原因是在这种情况下，sizeof()但为我们只是问一个整数的指针有多大，而不是我们动态分配了多少内存。

但是，有时 sizeof()的确如你所期望的那样工作：

```c
int x[10]; 
printf("%d\n", sizeof(x)); 
```

在这种情况下，编译器有足够的静态信息，知道已经分配了 40 个字节。（话说这也声明成全局变量，编译器也知道分配了40个字节）。

另外一个需要注意的地方是使用字符串。如果为一个字符串声明空间，请使用以下习惯用法：malloc(strlen(s) + 1)，它使用strlen()来获取字符串的长度，并加上1，以便为字符串结束符留出空间。这里使用sizeof()，可能会造成麻烦。

到 malloc()返回一个指向 void 类型的指针。这样做只是 C 中传回地址的 方式，让程序员决定如何处理它。

程序员将进一步使用所谓的强制类型转换（cast），强制类型转换事实上没干什么事，只是告诉编译器和其他可能正在读你的代码的程序员：“是的，我知道我在做什么。”通过强制转换 malloc()的结果，程序员只是在给人一些信心，强制转换不 是程序正确所必须的。

##### 14.3 free()调用

分配内存是等式的简单部分。知道何时、如何以及是否释放内存是困难的部分。要释放不再使用的堆内存，程序员只需调用free()。

```c
int *x = malloc(10 * sizeof(int)); 
... 
free(x); 
```

该函数接受一个参数，即一个由 malloc()返回的指针。 

因此，你可能会注意到，分配区域的大小不会被用户传入，必须由内存分配库本身记 录追踪。

##### 14.4 常见错误

在使用malloc()和free()时会出现一些常见的错误。

事实上，正确的内存管理就是这样一个问题，许多新语言都支持自动内存管理（automatic memory management）。在这样的语言中，当你调用类似malloc()的机制来分配内存时（通常用new或类似的东西来分配一个新对象），你永远不需要调用某些东西来释放空间。

实际上，垃圾收集器(garbage collector)会运行，找出你不再引用的内存，替你释放它。（这就是JAVA带给我的自信）

###### 忘记分配内存

许多例程在调用之前，都希望你为它们分配内存。例如，例程strcpy(dst,src)将源字符串中的字符串复制到目标指针。但是，如果你不小心，你可能会这样做。

```c
char *src = "hello"; 
char *dst; // oops! unallocated 
strcpy(dst, src); // segfault and die 
```

运行这段代码时，可能会导致段错误(segmentation fault)，这是一个很奇怪的术语，表示“你对内存犯了一个错误，你是不是啥b啊，这操作都能操作的出来？”

> 提示：它编译过了或它运行了!=它对了 （唐妞不等式ww）
>
> 仅仅因为程序编译过了甚至正确运行了一次或多次，并不意味着程序是正确的。许多事件可能会让你相信它能工作，但是之后有些事情会发生变化，它停止了。学生常见的反应是说（或者叫喊）“但它以前是好的！”，然后责怪编译器、操作系统、硬件，甚至是（我们敢说）教授。但是，问题通常就像你认为的那样，在你的代码中。在指责别人之前，先撸起袖子调试一下。

在这个例子中，正确的代码可能像这样：

```c
char *src = "hello"; 
char *dst = (char *) malloc(strlen(src) + 1); 
strcpy(dst, src); // work properly 
```

或者你可以用 strdup()，让生活本加轻松。阅读 strdup 的 man 手册页，了解本多信息。

> SYNOPSIS
>        #include <string.h>
>
>        char *strdup(const char *s);
>
> DESCRIPTION
>        The strdup() function returns a pointer to a new string which is a duplicate of the string s.         	       Memory for the new string is  obtained  with malloc(3), and can be freed with free(3).
>
> RETURN VALUE
>        On  success, the strdup() function returns a pointer to the duplicated
>        string.  It returns NULL if insufficient memory  was  available,  with
>        errno set to indicate the cause of the error

strdup会在内部调用malloc()分配内存，返回一个指向s复制的地址变量。

注意：要注意通过free()来手动的释放内存，否则会造成内存泄漏。

###### 没有分配足够的内存

另一个相关的错误是没有分配足够的内存，又是称为缓冲区溢出(buffer overflow)。在上面的例子中，一个常见的错误是为目标缓冲区留出“几乎”足够的空间。

```c
char *src = "hello"; 
char *dst = (char *) malloc(strlen(src)); // too small! 
strcpy(dst, src); // work properly 
```

奇怪的是，这个程序通常看起来会正常执行，这取决于如何实现 malloc 和许多其他细节。

在某些情况下，当字符串拷贝执行时，它会在超过分配空间的末尾处写入一个字节， 但在某些情况下，这是无害的，可能会覆盖不再使用的变量。

在某些情况下，这些溢出可 能具有令人难以置信的危害，实实上是系统中许多安全漏洞的来源。

在其他情况下， malloc 库总是分配一些额外的空间，因此你的程序实际上不会在其他某个变量的值上涂写， 并且工作得很好。

还有一些情况下，该程序确实会发生故障和崩溃。因此，我们学到了另 一个宝贵的教训：即使它正确运行过一次，也不意味着它是正确的。

###### 忘记初始化分配的内存

在这个错误中，你正确的调用了malloc()，但忘记在新分配的数据类型中填写一些值。如果你忘记了，如果你忘记了，你的程序最终会遇到未初始化的读取（uninitialized read），它从堆中读取了一些未知值的数据。

谁知道那里可能会有什么？如果走运，读到的值使程序仍然有效（例如，零）。如果不走运，会读到一些随机和有害的东西。

###### 忘记释放内存

另一个常见错误称为内存泄露（memory leak），如果忘记释放内存，就会发生。在长时间运行的应用程序或系统（如操作系统本身）中，这是一个巨大的问题，因为缓慢泄露的内存会导致内存不足，此时需要重新启动。

因此，一般来说，当你用完一段内存时，应该确保释放它。

请注意，使用垃圾收集语言（JAVA不行）在这里没有什么帮助：如果你仍然拥有对某块内 存的引用，那么垃圾收集器就不会释放它，因此即使在较现代的语言中，内存泄露仍然是 一个问题。

在某些情况下，不调用 free()似乎是合理的。例如，你的程序运行时间很短，很但就会退出。在这种情况下，当进程死亡时，操作系统将清理其分配的所有页面，因此不会发生内存泄露。

但这可能是一个坏习惯，所以请谨慎选择这样的策略。即使你不这样做也可以 逃脱惩罚，建议还是养成习惯，释放显式分配的每个字节。

###### 在用完之前释放内存 

在程序用完之前释放内存，这种错误被称为悬挂指针(dangling pointer)。随后的使用可能会导致程序崩溃或覆盖有效的内存。（例如，你调用了 free()，但随后再次调用 malloc()来分配其他内容，这重新利用了错误释放的 内存）。

###### 反复释放内存 

程序有时还会不止一次地释放内存，这被称为重复释放（double free）。这样做的结果是未定义的。正如你所能想象的那样，内存分配库可能会感到困惑，并且会做各种奇怪的 事情，崩溃是常见的结果。（出来啦！C语言特色，未定义的行为！）

###### 错误地调用 free() 

我们讨论的最后一个问题是 free()的调用错误。毕竟，free()期望你只传入之前从 malloc() 得到的一个指针。如果传入一些其他的值，坏事就可能发生（并且会发生）。因此，这种无效的释放（invalid free）是危险的，当然也应该避免。

> 补充：为什么在你的进程退出时没有内存泄露 
>
> 当你编写一个短时间运行的程序时，可能会使用 malloc()分配一些空间。程序运行并即将完成：是 否需要在退出前调用几次 free()？虽然不释放似乎不对，但在真正的意义上，没有任何内存会“丢失”。 原因很简单：系统中实际存在两级内存管理。 
>
> 第一级是由操作系统执行的内存管理，操作系统在进程运行时将内存交给进程，并在进程退出（或 以其他方式结束）时将其回收。第二级管理在每个进程中，例如在调用 malloc()和 free()时，在堆内管理。 即使你没有调用 free()（并因此泄露了堆中的内存），操作系统也会在程序结束运行时，收回进程的所有 内存（包括用于代码、栈，以及相关堆的内存页）。无论地址空间中堆的状态如何，操作系统都会在进 程终止时收回所有这些页面，从而确保即使没有释放内存，也不会丢失内存。 
>
> 因此，对于短时间运行的程序，泄露内存通常不会导致任何操作问题（尽管它可能被认为是不好的 形式）。如果你编写一个长期运行的服务器（例如 Web 服务器或数据库管理系统，它永远不会退出）， 泄露内存就是很大的问题，最终会导致应用程序在内存不足时崩溃。当然，在某个程序内部泄露内存是 一个更大的问题：操作系统本身。这再次向我们展示：编写内核代码的人，工作是辛苦的……

简而言之，内存管理是分级的，一级在进程内部，一级在操作系统本身。一个进程结束后会被操作系统回收，所以进程内部忘记释放的内存也随之回收了。

###### 小结 

如你所见，有很多方法滥用内存。由于内存出错很常见，整个工具生态圈已经开发出 来，可以帮助你在代码中找到这些问题。试试valgrind吧！

##### 14.5 底层操作系统支持 

你可能已经注意到，在讨论 malloc()和 free()时，我们没有讨论系统调用。原因很简单： 它们不是系统调用，而是库调用。因为这些库调用里里面包含了系统调用。也就是说，库帮我们封装了系统调用。

这些系统调用会进入操作系统，来请求本多内存或者将一 些内容释放回系统。

一个这样的系统调用叫作 brk，它被用来改变程序分断（break）的位置：堆结束的位置

它需要一个参数（新分断的地址），从而根据新分断是大于还是小于当前分断，来增加或减 小堆的大小。另一个调用 sbrk 要求传入一个增量，但目的是类似的。

请注意，你不应该直接调用 brk 或 sbrk。它们被内存分配库使用。如果你尝试使用它们， 很可能会犯一些错误。建议坚持使用 malloc()和 free()。

最后，你还可以通过 mmap()调用从操作系统获取内存。

通过传入正确的参数，mmap() 可以在程序中创建一个匿名（anonymous）内存区域——这个区域不与任何特定文件相关联， 而是与交换空间（swap space）相关联，稍后我们将在虚拟内存中详细讨论。这种内存也可 以像堆一样对待并管理。阅读 mmap()的手册页以获取更多详细信息。（之后在虚拟内存的时候再读手册）

##### 14.6 其他调用

内存分配库还支持一些其他调用。例如，calloc()分配内存，并在返回之前将其置零。（也就是malloc() + 全部置零初始化）当你为某些东西（比如一个数组）分配空间，然后需 要添加一些东西时，例程 realloc()也会很有用：realloc()创建一个新的本大的内存区域，将 旧区域复制到其中，并返回新区域的指针。