#### 抽象：地址空间

##### 13.1 早期系统

从内存来看，早期的机器并没有提供多少抽象给用户。基本上，及其的物理内存看起来如图所示/

<img src="D:\OS-TEP\OS-TEP\note\第13章 抽象：地址空间\屏幕截图 2024-01-30 143716.png" style="zoom:67%;" />

操作系统曾经是一组函数，在内存中，然后有一个正在运行的程序，目前在物理内存中，并使用剩余的内存。这里几乎没有抽象。

##### 13.2 多道程序和时分共享 

之后，由于机器昂贵，人们开始更有效的共享机器。因此，多道程序（multiprogramming）系统时代开启，其中多个进程在给定时间准备运行，比如当有一个进程在等待I/O操作时，操作系统会切换这些进程，这样增加了CPU的有效利用率（utilization）。

但很快，人们开始对机器要求更多，分时系统的时代诞生了。交互性（interactivity）变得很重要，因为许多用户可能同时在使用机器，每个人都在等待（或希望）他们执行的任务及时响应。

一种实现时分共享的方法，是让一个进程单独占用全部内存运行一小段时间然后停止它，并将它所有的状态信息保存在磁盘上（包含所有的物理内存），加载其他进程的状态信息，再运行一段时间，这就实现了某种比较粗糙的机器共享。

遗憾的是，这种方法有一个问题：太慢了，特别是当内存增长的时候。虽然保存和恢复寄存器级的状态信息（程序计数器、通用寄存器等）相对较快，但将全部的内存信息保存到磁盘就太慢了。因此，在进程 切换的时候，我们仍然将进程信息放在**内存**中。

<img src="D:\OS-TEP\OS-TEP\note\第13章 抽象：地址空间\屏幕截图 2024-01-30 144303.png" style="zoom: 67%;" />

随着时分共享变得更流行，人们对操作系统又有了新的要求，特别是多个程序同时驻留在内存中，使保护（protection）成为重要问题。人们不希望一个进程可以读取其他进程的内存，更别说修改了。

##### 13.3 地址空间 

操作系统需要提供一个易用（easy to use）的不利内存抽象，这个抽象叫做地址空间（address space）。

一个进程的地址空间包含运行的程序的所有内存状态。程序的代码（code），堆(heap)，栈（stack）。

我们有一个很小的地址空间 （只有 16KB）。程序代码位于地址空间的顶部。**代码是静态的（因此很容易放在内 存中），所以可以将它放在地址空间的顶部，我们知道程序运行时不再需要新的空间。**

<img src="D:\OS-TEP\OS-TEP\note\第13章 抽象：地址空间\屏幕截图 2024-01-30 144944.png" style="zoom:67%;" />

在运行中，地址空间可能有两个区域进行增长（或者收缩）。堆向下增长，栈向上增长。

然而，堆栈和堆的这种放置方法只是一种约定，如果你愿意， 可以用不同的方式安排地址空间。

> **关键问题：如何虚拟化内存** 
>
> 操作系统如何在单一的物理内存上为多个运行的进程（所有进程共享内存）构建一个私有的、可能 很大的地址空间的抽象？

当操作系统这样做时，我们说操作系统在**虚拟化内存**（virtualizing memory），因为运行 的程序认为它被加载到特定地址（例如 0）的内存中，并且具有非常大的地址空间（例如 32 位或 64 位）。现实很不一样。

操作系统在硬件的支持下，会将虚拟地址装载到对应的物理地址。这是内存虚拟化的关键，这是世界上每一个现代计算机系统的基础。

> **提示：隔离原则** 
>
> 隔离是建立可靠系统的关键原则。如果两个实体相互隔离，这意味着一个实体的失败不会影响另一 个实体。操作系统力求让进程彼此隔离，从而防止相互造成伤害。通过内存隔离，操作系统进一步确保 运行程序不会影响底层操作系统的操作。一些现代操作系统通过将某些部分与操作系统的其他部分分离，实现进一步的隔离。这样的微内核（microkernel）可以比整体内核提供更大 的可靠性。

##### 13.4 目标 

虚拟内存（VM）系统的一个主要目标是透明（transparency）（这里透明的含义是隐形，即不被程序感知到）。操作系统实现虚拟内存的方式，应该让运行的内存看不见。程序不该感知到内存被虚拟化的事实，而是认为其拥有自己的私有物理内存。操作系统和硬件完成了所有的工作，来实现这个假象

虚拟内存的另一个目标是效率（efficiency）。操作系统应该追求虚拟化尽可能高效，无论是在时间上还是空间上。在实现高效率虚拟化时，操作系统将不得不依靠硬件支持，包括 TLB 这样 的硬件功能（我们将在适当的时候学习）。

最后，虚拟内存的第三个目标是保护（protection）。操作系统应确保内存受到保护，不会受其他进程影响，操作系统本身也不会受进程影响。因此，保护让我们能够在进程之间提供隔离（isolation） 的特性，每个进程都应该在自己的独立环境中运行，避免其他出错或恶意进程的影响。

> 补充：你看到的所有地址都不是真的 
>
> 写过打印出指针的 C 程序吗？你看到的值（一些大数字，通常以十六进制打印）是虚拟地址（virtual  address）。有没有想过你的程序代码在哪里找到？你也可以打印出来，是的，如果你可以打印它，它也 是一个虚拟地址。实际上，作为用户级程序的程序员，可以看到的任何地址都是虚拟地址。只有操作系 统，通过精妙的虚拟化内存技术，知道这些指令和数据所在的物理内存的位置。所以永远不要忘记：如 果你在一个程序中打印出一个地址，那就是一个虚拟的地址。虚拟地址只是提供地址如何在内存中分布 的假象，只有操作系统（和硬件）才知道物理地址。 
>
> 这里有一个小程序，打印出 main() 函数（代码所在地方）的地址，由 malloc()返回的堆空间分配的 值，以及栈上一个整数的地址： 
>
> ```c
> #include <stdio.h>
> #include <stdlib.h>
> int main(int argc, char *argv[]) {   
>     printf("location of code : %p\n", (void *) main);   
>     printf("location of heap : %p\n", (void *) malloc(1));   
>     int x = 3;   
>     printf("location of stack : %p\n", (void *) &x);   
>     return x;   
> }  
> ```
>
> 在 64 位的 Mac 上面运行时，我们得到以下输出： 
>
> ```
> location of code : 0x1095afe50  
> location of heap : 0x1096008c0  
> location of stack : 0x7fff691aea64  
> ```
>
> 从这里，你可以看到代码在地址空间开头，然后是堆，而栈在这个大型虚拟地址空间的另一端。所有 这些地址都是虚拟的，并且将由操作系统和硬件翻译成物理地址，以便从真实的物理位置获取该地址的值。