####  信号量

我们现在知道，并发问题需要通过锁和条件变量来解决。多年前，认识到这一点的人之一就是Dijkstra（据传言，他说过写goto的人都是啥b）。他引入了名为信号量的同步原语，作为与同步有关的所有工作的唯一原语。你会看到，可以使用信号量作为锁和条件变量。

> **关键问题：如何使用信号量？** 
>
> 如何使用信号量代替锁和条件变量？什么是信号量？什么是二值信号量？用锁和条件变量来实现 信号量是否简单？不用锁和条件变量，如何实现信号量？

##### 31.1 信号量的定义 

信号量是一个有整数值的对象，可以用两个函数来操纵它。在POSIX标准中，时sem_wait()和sem_post()。因为信号量的初始值能决定其行为，所以要先初始化信号量，才能调用函数与其进行交互。

```c
#include <semaphore.h> 
sem_t s; 
sem_init(&s, 0, 1); //第一个参数是信号量 第二个是模式 第三个是信号量的初始值
```

第二个参数设为0，代表信号量是在同一进程的多个线程共享的。

```c
int sem_wait(sem_t *s) {
	// decrement the value of semaphore s by one
	// wait if value of semaphore s is negative
    // return immediately if value of semaphore s is not negative
}

int sem_post(sem_t *s) {
	// increment the value of semaphore s by one
	// if there are one or more threads waiting, wake one
}
```

##### 31.2 二值信号量（锁） 

现在我们要使用信号量了，第一种用法是我们熟悉的：将信号量作为锁。

```c
sem_t m;
sem_init(&m, 0, X); // initialize semaphore to X; what should X be? X should be one

sem_wait(&m);
// critical section here
sem_post(&m);
```

wait将s的值-1，post将s的值+1，并唤醒正在等待的wait()。

我们可以用信号量来实现锁了。因为锁只有两个状态（持有和没持有），所以这种用法有时也叫作二值信号量（binary semaphore）。

事实上这种信号量也有一些更简单的实现，我们这里使用了更为通用的信号量作为锁。

无论有多少个线程，信号量的初始值应该始终为1。

##### 31.3 信号量用作条件变量

信号量也可以用在一个线程暂停执行，等待某一条件成立的场景。例如，一个线程要等待另一个链表非空，然后才能删除一个元素。在这种情况下，通常一个线程等待条件成立，另外一个线程修改条件并发信号给等待线程，从而唤醒等待线程。因为等待线程在等待某些条件（condition）发生变化，因此我们将信号量作为条件变量（condition variable）。

```c
sem_t s;

void *
child(void *arg) {
	printf("child\n");
	sem_post(&s); // signal here: child is done
	return NULL;
}

int
main(int argc, char *argv[]) {
	sem_init(&s, 0, X); // what should X be?
	printf("parent: begin\n");
	pthread_t c;
	Pthread_create(c, NULL, child, NULL);
	sem_wait(&s); // wait here for child
	printf("parent: end\n");
	return 0;
}
```

此时的信号量初始值应该为0，且只能为0（首先不可能是正数，如果是负数的话可能会导致父线程一直休眠）。

##### 31.4 生产者/消费者（有界缓冲区）问题 

我们用两个信号量 empty 和 full 分别表示缓冲区空或者满。

```c
int buffer[MAX];
int fill = 0;
int use = 0;
void put(int value) {
	buffer[fill] = value; // line f1
	fill = (fill + 1) % MAX; // line f2
}

int get() {
	int tmp = buffer[use]; // line g1
	use = (use + 1) % MAX; // line g2
	return tmp;
}
```

```c
sem_t empty;
sem_t full;

void *producer(void *arg) {
	int i;
	for (i = 0; i < loops; i++) {
		sem_wait(&empty); // line P1
		put(i); // line P2
		sem_post(&full); // line P3
	}
}

void *consumer(void *arg) {
	int i, tmp = 0;
	while (tmp != -1) {
		sem_wait(&full); // line C1
		tmp = get(); // line C2
		sem_post(&empty); // line C3
		printf("%d\n", tmp);
	}

}

int main(int argc, char *argv[]) {
	// ...
	sem_init(&empty, 0, MAX); // MAX buffers are empty to begin with...
	sem_init(&full, 0, 0); // ... and 0 are full
	// ...
}
```

但sem_wait()毕竟不是wait()，当MAX大于1时会产生竞态条件，即有多个线程同时进入临界区。

###### 解决方案：增加互斥 

我们使用二值信号量来增加锁。

```c
sem_t empty;
sem_t full;
sem_t mutex;

void *producer(void *arg) {
	int i;
	for (i = 0; i < loops; i++) {
		sem_wait(&mutex); // line p0 (NEW LINE)
		sem_wait(&empty); // line p1
		put(i); // line p2
		sem_post(&full); // line p3
		sem_post(&mutex); // line p4 (NEW LINE)
	}
}

void *consumer(void *arg) {
	int i;
	for (i = 0; i < loops; i++) {
		sem_wait(&mutex); // line c0 (NEW LINE)
		sem_wait(&full); // line c1
		int tmp = get(); // line c2
		sem_post(&empty); // line c3
		sem_post(&mutex); // line c4 (NEW LINE)
		printf("%d\n", tmp);
	}
}

int main(int argc, char *argv[]) {
	// ...
	sem_init(&empty, 0, MAX); // MAX buffers are empty to begin with...
	sem_init(&full, 0, 0); // ... and 0 are full
	sem_init(&mutex, 0, 1); // mutex=1 because it is a lock (NEW LINE)
	// ...
}
```

但还是我们出现过的老问题sem_wait()不是wait()，在该线程休眠的时候，依然持有锁。所以，这会导致死锁的发生。

###### 最后，可行的方案 

要解决这个问题，只需减少锁的作用域。

把获取和释放互斥量的操作调整为紧挨着临界区，把 full、empty 的唤醒和等待操作调整到锁外面。

结果得到了简单而有效的有界缓冲区，多线程程序的常用模式。现在理解，将来使用。 未来的岁月中，你会感谢我们的。

（也就是，只有符合资格操作的线程，才能拿到锁；而不是先拿锁，再看能不能操作）

```c
sem_t empty;
sem_t full;
sem_t mutex;

void *producer(void *arg) {
	int i;
	for (i = 0; i < loops; i++) {
		sem_wait(&empty); // line p1
		sem_wait(&mutex); // line p1.5 (MOVED MUTEX HERE...)
		put(i); // line p2
		sem_post(&mutex); // line p2.5 (... AND HERE)
		sem_post(&full); // line p3
	}
}

void *consumer(void *arg) {
	int i;
	for (i = 0; i < loops; i++) {
		sem_wait(&full); // line c1
		sem_wait(&mutex); // line c1.5 (MOVED MUTEX HERE...)
		int tmp = get(); // line c2
		sem_post(&mutex); // line c2.5 (... AND HERE)
		sem_post(&empty); // line c3
		printf("%d\n", tmp);
	}
}

int main(int argc, char *argv[]) {
	// ...
	sem_init(&empty, 0, MAX); // MAX buffers are empty to begin with...
	sem_init(&full, 0, 0); // ... and 0 are full
	sem_init(&mutex, 0, 1); // mutex=1 because it is a lock
	// ...
}
```

##### 31.5 读者—写者锁

另一个经典问题源于对更加灵活的锁定原语的渴望，他承认不同的数据结构访问可能需要不同类型的锁。

例如，一个并发链表有很多插入和查找操作。插入操作会修改链表的 状态（因此传统的临界区有用），而查找操作只是读取该结构，只要没有进行插入操作，我们可以并发的执行多个查找操作。

读者—写者锁（reader-writer lock）就是用来完成这种操作的。

如果某个线程要更新数据结构，需要调用 rwlock_acquire_lock()获得写锁， 调用 rwlock_release_writelock()释放锁。内部通过一个 writelock 的信号量保证只有一个写者 能获得锁进入临界区，从而更新数据结构。

```c
typedef struct _rwlock_t {
	sem_t lock; // binary semaphore (basic lock)
	sem_t writelock; // used to allow ONE writer or MANY readers
	int readers; // count of readers reading in critical section 现在临界区的读者数
} rwlock_t;

void rwlock_init(rwlock_t *rw) {//初始化锁
	rw->readers = 0;
	sem_init(&rw->lock, 0, 1);
	sem_init(&rw->writelock, 0, 1);
}

void rwlock_acquire_readlock(rwlock_t *rw) {//获取读写锁
	sem_wait(&rw->lock);//临界区锁
	rw->readers++;
	if (rw->readers == 1)
		sem_wait(&rw->writelock); // first reader acquires writelock
	sem_post(&rw->lock);
}

void rwlock_release_readlock(rwlock_t *rw) {//释放读写锁
	sem_wait(&rw->lock);
	rw->readers--;
	if (rw->readers == 0)
		sem_post(&rw->writelock); // last reader releases writelock
	sem_post(&rw->lock);
}

void rwlock_acquire_writelock(rwlock_t *rw) {//获取读写锁
	sem_wait(&rw->writelock);
}

void rwlock_release_writelock(rwlock_t *rw) {//释放读写锁
	sem_post(&rw->writelock);
}
```

第一个读者持有读锁，最后一个读者释放读锁（原来还是有不互斥的锁的ww）。

只有当没有读者的时候，写者才能获取锁。

> 提示：简单的笨办法可能更好（Hill 定律） 
>
> 我们不能小看一个概念，即简单的笨办法可能最好。某些时候简单的自旋锁反而是最有效的，因为 它容易实现而且高效。虽然读者—写者锁听起来很酷，但是却很复杂，复杂可能意味着慢。因此，总是 优先尝试简单的笨办法。 
>
> 这种受简单吸引的思想，在多个地方都能发现。一个早期来源是 Mark Hill 的学位论文[H87]，研究 如何为 CPU 设计缓存。Hill 发现简单的直接映射缓存比花哨的集合关联性设计更加有效（一个原因是在 缓存中，越简单的设计，越能够更快地查找）。Hill 简洁地总结了他的工作：“大而笨更好。”因此我们 将这种类似的建议叫作 Hill 定律（Hill’s Law）。

这样方法可行，但是有缺陷，在公平性上。读者很容易饿死死者。

最后，应该指出，读者-写者锁还有一些注意点。它们通常加入了更多开锁（尤其是更复杂的实现），因此和其他一些简单快速的锁相比，读者写者锁在性能方面没有优势[CB08]。 无论哪种方式，它们都再次展示了如何以有趣、有用的方式来使用信号量。

##### 31.6 哲学家就餐问题

这个问题的基本情况是（见图 31.10）：假定 有 5 位“哲学家”围着一个圆桌。每两位哲学家 之间有一把餐叉（一共 5 把）。哲学家有时要思 考一会，不需要餐叉；有时又要就餐。而一位哲 学家只有同时拿到了左手边和右手边的两把餐 叉，才能吃到东西。

关于餐叉的竞争以及随之而来的同步问题，就是我们在并发编程中研 究它的原因。

下面是每个哲学家的基本循环：

```c
while(1){
	think();
	getforks();
	eat();
	putforks();
}
```

关键的挑战就是如何实现 getforks()和 putforks()函数，保证没有死锁，没有哲学家饿死， 并且并发度更高（尽可能让更多哲学家同时吃东西）。

根据 Downey 的解决方案[D08]，我们会用一些辅助函数，帮助构建解决方案。它们是：

```c
int left(int p) { return p; } 
int right(int p) { return (p + 1) % 5; } 
```

如果哲学家 p 希望用左手边的叉子，他们就调用 left(p)。类似地，右手边的叉子就用 right(p)。模运算解决了最后一个哲学家（p = 4）右手边叉子的编号问题，就是餐叉 0。 

我们需要一些信号量来解决这个问题。假设需要 5 个，每个餐叉一个：sem_t forks[5]。

###### 有问题的解决方案(死锁)

```c
void getforks() { 
sem_wait(forks[left(p)]); 
sem_wait(forks[right(p)]); 
} 
 
void putforks() { 
sem_post(forks[left(p)]); 
sem_post(forks[right(p)]); 
} 
```

假设每个哲学家都拿到了左手边的餐叉，他们每个都会阻塞 住，并且一直等待另一个餐叉。

###### 一种方案：破除依赖 

解决上述问题最简单的方法，就是修改某个或者某些哲学家的取餐叉顺序。事实上， Dijkstra 自己也是这样解决的。

具体来说，假定哲学家 4（编写最大的一个）取餐叉的顺序不同。

```c
void getforks() {
	if (p == 4) {
		sem_wait(forks[right(p)]);
		sem_wait(forks[left(p)]);
	} else {
		sem_wait(forks[left(p)]);
		sem_wait(forks[right(p)]);
	}
}
```

因为最后一个哲学家会尝试先拿右手边的餐叉，然后拿左手边，所以不会出现每个哲 学家都拿着一个餐叉，卡住等待另一个的情况，等待循环被打破了。想想这个方案的后果， 让你自己相信它有效。

##### 31.7 如何实现信号量 

最后，我们用底层的同步原语（锁和条件变量），来实现自己的信号量。 

```c
typedef struct _Zem_t {
	int value;
	pthread_cond_t cond;
	pthread_mutex_t lock;
} Zem_t;

// only one thread can call this
void Zem_init(Zem_t *s, int value) {
	s->value = value;
	Cond_init(&s->cond);
	Mutex_init(&s->lock);
}

void Zem_wait(Zem_t *s) {
	Mutex_lock(&s->lock);//获取锁
	while (s->value <= 0)//当信号量的值小于等于0时 休眠
		 Cond_wait(&s->cond, &s->lock);
	s->value--;//信号量--
	Mutex_unlock(&s->lock);//释放锁
}

void Zem_post(Zem_t *s) {
	Mutex_lock(&s->lock);//获取锁
	s->value++;//信号量++
	Cond_signal(&s->cond);//随机唤醒一个线程
	Mutex_unlock(&s->lock);//释放锁
}
```

可以看到，我们只用了一把锁、一个条件变量和一个状态的变量来记录信号量的值。

> **提示：小心泛化**
>
> 在系统设计中，泛化的抽象技术是很有用处的。一个好的想法稍微扩展之后，就可以解决更大一类 问题。然而，泛化时要小心，正如 Lampson 提醒我们的“不要泛化。泛化通常都是错的。”[L83]  
>
> 我们可以把信号量当作锁和条件变量的泛化。但这种泛化有必要吗？考虑基于信号量去实现条件变量的难度，可能这种泛化并没有你想的那么通用。

很奇怪，利用信号量来实现锁和条件变量，是棘手得多的问题。某些富有经验的并发 程序员曾经在 Windows 环境下尝试过，随之而来的是很多缺陷[B04]。你自己试一下，看看 是否能明白为什么使用信号量实现条件变量比看起来更困难。