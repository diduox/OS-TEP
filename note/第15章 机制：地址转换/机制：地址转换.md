#### 机制：地址转换

在实现CPU虚拟化时，我们遵循的一般准则被称为受限直接访问（Limited Direct Execution,LDE）。LDE背后的想法很简单：让运行的大部分指令直接访问硬件，只在一些关键点（如进程发起系统调用或发生时钟中断）由操作系统介入来确保“在正确的时间，正确的地点，做正确的事”。为了实现高效的虚拟化，操作系统应该尽量让程序自己运行，同时通过在关键点的及时介入(interposing)，来保持对硬件的控制。**高效和控制是现代操作系统的两个主要目标。**

在实现虚拟内存时，我们将追求类似的战略，在实现高效和控制的同时，提供期望的虚拟化。**高效决定了我们要利用的硬件的支持**，这在开始的时候非常初级（如使用一些寄存器），但会变得相当复杂（比如我们会讲到的 TLB、页表等）。

**控制意味着操作系统要确保应用程序只能访问它自己的内存空间**。因此，要保护应用程序不会相互影响，也不会影响操作系统，我们需要硬件的帮助。（比操作系统更高一级吗ww）

最后，我们对虚拟内存还有一点要求，即**灵活性**。具体来说，我们希望应用程序能以任何方式访问它自己的地址空间，从而让系统更容易编程。所以，关键问题在于：

> 关键问题：如何高效、灵活地虚拟化内存  
>
> 如何实现高效的内存虚拟化？如何提供应用程序所需的灵活性？如何保持控制应用程序可访问的内存位置，从而确保应用程序的内存访问受到合理的限制？如何高效地实现这一切？

我们利用了一种通用技术，有时被称为基于硬件的地址转换（hardware-based address translation），简称为地址转换（address translation）。它可以看成是受限直接执行这种一般方法的补充。

利用地址转换，硬件对每次内存访问进行处理（即指令获取、数据读写或写入），将指令中的虚拟（virtual）地址转换为数据实际存储的物理（physical）地址。

因此，在每次内存引用时，硬件都会进行地址转换，将应用程序的内存引用重定位到内存中实际的位置。

当然，仅仅依靠硬件不足以实现虚拟内存，因为它只是提供了底层机制来提高效率。操作系统必须在关键的位置介入，设置好硬件，以便完成正确的地址转换。

因此它必须管理内存（manage memory），记录被占用和空闲的内存位置，并明智而谨慎地介入，保持对内存使用的控制。



同样，这些所有的工作都是为了创建一个假象：每个程序都拥有私有的内容，那里存放着它自己的代码和数据。

虚拟现实的背后是丑陋的物理事实：许多程序其实是在同一时间内共享着内存。

##### 15.1   假设 

我们先假设用户的地址空间必须连续地放在物理内存中。同时，为了简单，我们假设地址空间不是很大，具体来说，小于物理内存的大小。最后，假设每个地址空间的大小完全一样。

##### 15.2  一个例子

为了更好地理解实现地址转换需要什么，以及为什么需要，我们先来看一个简单的例子。

这里我们要检查一小段代码，它从内存中加载一 个值，对它加3，然后将它存回内存。

```c
void func() {  
    int x; 
	x = x + 3; // this is the line of code we are interested in 
}
```

编译器将这行代码转化为汇编语句，可能像下面这样（x86 汇编）。我们可以用 Linux 的objdump 或者Mac的otool将它反汇编：

```assembly
128: movl 0x0(%ebx), %eax   ;load 0+ebx into eax 
132: addl $0x03, %eax       ;add 3 to eax register 
135: movl %eax, 0x0(%ebx)   ;store eax back to mem 
```

这段代码相对简单，它假定x的地址已经存入寄存器ebx，之后通过movl指令将这个 地址的值加载到通用寄存器eax（长字移动）。下一条指令对eax的内容加3。最后一条指令 将eax中的值写回到内存的同一位置。

> 提示：介入（Interposition）很强大  
>
> 介入是一种很常见又很有用的技术，计算机系统中使用介入常常能带来很好的效果。在虚拟内存中， 硬件可以介入到每次内存访问中，将进程提供的虚拟地址转换为数据实际存储的物理地址。但是，一般化的介入技术有更广阔的应用空间，实际上几乎所有良好定义的接口都应该提供功能介入机制，以便增加功能或者在其他方面提升系统。这种方式最基本的优点是透明（transparency），介入完成时通常不需要改动接口的客户端，因此客户端不需要任何改动。

在图15.1中，可以看到代码和数据都位于进程的地址空间，3条代码位于地址128 （靠近头部的代码段），变量x的值位于地址15KB（在靠近底部的栈中）。如图15.1所示，x 的初始值是3000。

如果这3条指令执行，从进程的角度来看，发生了以下几次内存访问：

- **从地址128获取指令；**  
- **执行指令（从地址15KB加载数据）；**  
- **从地址132获取命令；**  
- **执行命令（没有内存访问）；**  
- **从地址135获取指令；**  
- **执行指令（新值存入地址15KB）。**

从程序的角度来看，它的地址空间（address space）从0开始到16KB结束。它包含的所有内存引用都应该在这个范围内。然而，对虚拟内存来说，操作系统希望将这个进程地址空间放在物理内存的其他位置，并不一定从地址 0 开始。

因此我们遇到了如下问题：怎样在内存中重定位这个进程，同时对该进程透明（transparent）（使进程不知道，或者说不用关心我们的重定位操作）？怎么样提供一种虚拟地址空间从0开始的假象，而实际上地址空间位于另外某个物理地址？ 

图15.2 展示了一个例子，说明这个进程的地址空间被放入物理内存后可能的样子。从 图15.2 中可以看到，操作系统将第一块物理内存留给了自己，并将上述例子中的进程地址空 间重定位到从32KB开始的物理内存地址。剩下的两块内存空闲（16～32KB和48～64KB）。

<img src="D:\OS-TEP\OS-TEP\note\第15章 机制：地址转换\屏幕截图 2024-02-01 192150.png" style="zoom: 67%;" />